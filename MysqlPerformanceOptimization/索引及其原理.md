# MySQL性能优化（一）-MySQL索引及原理

### #概念

在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。**简单来说索引就相当于书籍的目录，可以根据书籍目录上记载的页数快速找到想要查找的内容。**

![picture1](D:\Skill\Git\Repository\Notebook\MysqlPerformanceOptimization\images\picture1.png)



### #为什么要用索引

1，**索引能极大的减少存储引擎需要扫描的数据量**

​	还是拿一本书（表）举例，如果我们不知道要查找的文字（数据）在哪一页（行），我们要整本书（表）的去查找，但是有了目录（索引），我们根据目录（索引）就知道了我们要找的文字（数据）在哪一页（行），所以减少了要查找的页数（数据）。

2，**索引可以把随机IO变成顺序IO** 

​	答案在下面覆盖索引处。



### #为什么要选择B+Tree

这里对于详细的概念不做太多的介绍，如果不太理解概念可以先去补下概念。

##### 平衡二叉树

​	是一种二叉排序树，其中每个结点的左子树和右子树的高度差至多等于1。它是一种高度平衡的二叉排序树。

​	下图是平衡二叉树的结构图，每个磁盘块包括关键字，数据区和子节点引用。关键字就是用于比较的关键字，数据区就是保存数据的地方，数据可能是要查找的数据，但为了节约数据块，更多存的是数据的地址，在根据这个地址去拿到对应的数据，节点引用就是下个节点的指针，包含左节点和又节点。

![picture3](D:\Skill\Git\Repository\Notebook\MysqlPerformanceOptimization\images\picture3.png)

**缺点：**

​	它太深了：数据处的（高）深度决定着他的IO操作次数，IO操作耗时大 

​	它太小了：每一个磁盘块（节点/页）保存的数据量太小了 

​	没有很好的利用操作磁盘IO的数据交换特性， 也没有利用好磁盘IO的预读能力（空间局部性原理），从而带来频繁的IO操作



##### 多路平衡查找树（B-Tree）

​	B树和平衡二叉树稍有不同的是**B树属于多叉树又名平衡多路查找树（查找路径不只两个）**，数据库索引技术里大量使用者B树和B+树的数据结构。

​	每个磁盘块和平衡二叉树的组成是一样的。包括关键字，数据区和子节点引用。

![picture4](D:\Skill\Git\Repository\Notebook\MysqlPerformanceOptimization\images\picture4.png)

**优点：**

​	保存的数据量比平衡二叉树多 

​	很好的利用操作磁盘IO的数据交换特性， 也利用好磁盘IO的预读能力（空间局部性原理），从而减少频繁的IO操作



##### 加强版多路平衡查找树（B+Tree）

​	B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。

​	每个磁盘块和B树相比有很大区别了。

​	**1，B+节点关键字搜索采用闭合区间** 

​	**2，B+非叶节点不保存数据相关信息，只保存关键字和子节点的引用** 

​	**3，B+关键字对应的数据保存在叶子节点中** 

​	**4，B+叶子节点是顺序排列的，并且相邻节点具有顺序引用的关系**

![picture5](D:\Skill\Git\Repository\Notebook\MysqlPerformanceOptimization\images\picture5.png)

**和B树相比的优点：**

​	1、B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；

​	2、B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

​	3、B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。

​	4、B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。



##### 结论：

​	**B+树是B树的变种（多路绝对平衡查找树），他拥有B树的优势**

​	**B+树扫库、表能力更强** 

​	**B+树的磁盘读写能力更强** 

​	**B+树的排序能力更强** 



### #Mysql在Innodb引擎中B+Tree索引体现形式

​	以主键为索引来组织数据的存储，如果没有主键，会默认隐性生成一个6bit的主键，只是你看不到而已。数据库表中数据的物理顺序与主键的逻辑索引的顺序是相同的（也可以叫做聚集索引）。你可以认为mysql是以聚集索引来组织数据的。在叶子节点的数据区会保存该主键的所有数据。

![picture6](D:\Skill\Git\Repository\Notebook\MysqlPerformanceOptimization\images\picture6.png)

如果有name索引是怎么查找数据的呢？它会为name创建一个辅助索引，叶子节点是主键Id，查找到对应的主键，再去主键索引中找到数据。

![picture7](D:\Skill\Git\Repository\Notebook\MysqlPerformanceOptimization\images\picture7.png)

为什么要查两次呢？第一，设计时候认为主键是我最常用的索引，所以我以主键去组织数据，使得查找更快。第二，如果查一次就要在辅助索引的叶子节点保存所有数据，这样的话当数据更新或者删除的时候要维护两个索引的数据。



### #索引知识补充

**列的离散性**

​	离散性越高，选择性就越好，公式：count(distinct col):count(col)。简单来讲重复率越低，离散性越高。

​	在下面哪一列离散性最好？name列，因为只有name列无重复数据。

​	![picture8](D:\Skill\Git\Repository\Notebook\MysqlPerformanceOptimization\images\picture8.png)

**最左匹配原则**

​	顾名思义：最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。

​	比如我建立一个（a，b）索引，那么我能匹配到（a）（a，b），而（b）是不会用到索引的。

**联合索引**

​	**单列索引：**节点中关键字[name] ，树节点的关键字就是name，比james。

​	**联合索引：**节点中关键字[name,address] ，树节点的关键字就是name+address，比如james,beijing

​	**单列索引是特殊的联合索引** 

​	**联合索引列选择原则** 

​		1，经常用的列优先 【最左匹配原则】 

​		2，选择性（离散度）高的列优先【离散度高原则】 

​		3，宽度小的列优先【最少空间原则】

**覆盖索引**

​	如果查询列可通过索引节点中的关键字直接返回，则该索引称之为覆盖索引。

​	我们可以这样理解，比如我们有索引（name，address），我们的查询语句是 SELECT name, address FROM Student WHERE name = ?，这样我们要查询的结果正好是索引的数据，就不用通过主键索引去查找数据区的数据就可以得到结果，这样就叫做覆盖索引。

​	覆盖索引可减少数据库IO，将随机IO变为顺序IO，可提高查询性能。

​	而且很多公司也不允许使用select *也是这个道理。因为可能会命中覆盖索引，一旦命中覆盖索引，就不会做叶子节点的IO操作，提高性能。



### 总结：

​	索引列的数据长度能少则少。 

​	索引一定不是越多越好，越全越好，一定是建合适的。 

​	匹配列前缀可用到索引 like 9999%，like %9999%、like %9999用不到索引； 

​	Where 条件中 not in 和 !=操作无法使用索引； 

​	匹配范围值，order by 也可用到索引； 

​	多用指定列查询，只返回自己想到的数据列，少用select *； 

​	联合索引中如果不是按照索引最左列开始查找，无法使用索引； 

​	联合索引中精确匹配最左前列并范围匹配另外一列可以用到索引； 

​	联合索引中如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引；

​	