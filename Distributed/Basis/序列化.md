## 分布式系统的基石-序列化

- **什么是序列化**

  Java 平台允许我们在内存中创建可复用的Java 对象，但一般情况下，只有当JVM 处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM 的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java 对象序列化就能够帮助我们实现该功能。

  简单来说，序列化是把对象的状态信息转化为可存储或传输的形式过程，也就是把对象转化为字节序列的过程称为对象的序列化反序列化是序列化的逆向过程，把字节数组反序列化为对象，把字节序
  列恢复为对象的过程成为对象的反序列化

- **SerialVersionUID 的作用**
  Java 的序列化机制是通过判断类的serialVersionUID 来验证版本一致性的。在进行反序列化时，JVM 会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即
  是InvalidCastException

  - 如果没有为指定的class 配置serialVersionUID，那么java 编译器会自动给这个class 进行一个摘要算法，类似于指纹算法，只要这个文件有任何改动，得到的UID 就会截然不同的，可以保证在这么多类中，这个编号是唯一的.。
  - **serialVersionUID 有两种显示的生成方式：**
    一是默认的1L，比如：private static final long serialVersionUID = 1L;
    二是根据类名、接口名、成员方法及属性等来生成一个64 位的哈希字段
  - 当实现java.io.Serializable 接口的类没有显式地定义一个serialVersionUID 变量时候，Java 序列化机制会根据编译的Class 自动生成一个serialVersionUID 作序列化版本比较用，这种情况下，如果
    Class 文件(类名，方法明等)没有发生变化(增加空格，换行，增加注释等等)，就算再编译多次，serialVersionUID 也不会变化的。

- **结论**

  - 当一个父类没有实现序列化时，子类继承该父类并且实现了序列化。在反序列化该子类后，是没办法获取到父类的属性值的
  - 当一个父类实现序列化，子类自动实现序列化，不需要再显示实现Serializable 接口
  - 当一个对象的实例变量引用了其他对象，序列化该对象时也会把引用对象进行序列化，但是前提是该引用对象必须实现序列化接口

- **Transient 关键字**

  - Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient变量的值被设为初始值，如 int 型的是 0，对象型的是 null。

- **常见的序列化技术**

  - **使用JAVA 进行序列化**
    优点：JAVA 语言本身提供，使用比较方便和简单
    缺点：不支持跨语言处理、 性能相对不是很好，序列化以后产生的数据相对较大

  - **XML 序列化框架**
    XML 序列化的好处在于可读性好，方便阅读和调试。但是序列化以后的字节码文件比较大，而且效率不高，适用于对性能不高，而且QPS 较低的企业级内部系统之间的数据交换的场景，同时XML 又具有语言无关性，所以还可以用于异构系统之间的数据交换和协议。比如我们熟知的Webservice，就是采用XML 格式对数据进行序列化的。

  - **JSON 序列化框架**
    JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，相对于XML 来说，JSON 的字节流更小，而且可读性也非常好。现在JSON数据格式在企业运用是最普遍的。

    - JSON 序列化常用的开源工具有很多
      - Jackson （https://github.com/FasterXML/jackson）
      - 阿里开源的FastJson （https://github.com/alibaba/fastjon）
      - Google 的GSON (https://github.com/google/gson)
    - 这几种json 序列化工具中，Jackson 与fastjson 要比GSON 的性能要好，但是Jackson、GSON 的稳定性要比Fastjson 好。而fastjson 的优势在于提供的api 非常容易使用。

  - **Hessian 序列化框架**
    Hessian 是一个支持跨语言传输的二进制序列化协议，相对于Java 默认的序列化机制来说，Hessian 具有更好的性能和易用性，而且支持多种不同的语言实际上Dubbo 采用的就是Hessian 序列化来实现，只不过Dubbo 对Hessian 进行了重构，性能更高。

  - **Protobuf 序列化框架**
    Protobuf 是Google 的一种数据交换格式，它独立于语言、独立于平台。Google 提供了多种语言来实现，比如Java、C、Go、Python，每一种实现都包含了相应语言的编译器和库文件Protobuf 使用比较广泛，主要是空间开销小和性能比较好，非常适合用于公司内部对性能要求高的RPC 调用。 另外由于解析性能比较高，序列化以后数据量相对较少，所以也可以应用在对象的持久化场景中
    但是但是要使用Protobuf 会相对来说麻烦些，因为他有自己的语法，有自己的编译器。

    - **Protobuf 原理分析**
      核心原理： protobuf 使用varint（zigzag）作为编码方式， 使用T-LV作为存储方式varint 编码方式varint 是一种数据压缩算法，其核心思想是利用bit 位来实现数据压缩。
      比如：对于 int32 类型的数字，一般需要 4 个字节 表示；若采用Varint 编码，对于很小的 int32 类型 数字，则可以用 1 个字节。
      假设我们定义了一个int32 字段值=296.
      **第一步，转化为2 进制编码**

      ![1556177730](C:\Xingwei\Owner\Typora\Typora\Notebook\Distributed\images\1556177730.jpg)

  ​              **第二步，提取字节**
  ​              规则： 按照从字节串末尾选取7 位，并在最高位补1，构成一个字节

  ![1556177774(1)](C:\Xingwei\Owner\Typora\Typora\Notebook\Distributed\images\1556177774(1).jpg)

  ​              **第三步，继续提取字节**
  ​	      整体右移7 位，继续截取7 个比特位，并且在最高位补0 。因为这个是最后一个有意义的字

  ​              节了。补0 不影响结果

  ![1556177843(1)](C:\Xingwei\Owner\Typora\Typora\Notebook\Distributed\images\1556177843(1).jpg)


​                     **第四步，拼接成一个新的字节串**
​                     将原来用4 个字节表示的整数，经过varint 编码以后只需要2 个字节了。

![1556177892(1)](C:\Xingwei\Owner\Typora\Typora\Notebook\Distributed\images\1556177892(1).jpg)



- **总结**
  Protocol Buffer 的性能好，主要体现在 序列化后的数据体积小 & 序列化速度快，最终使得传输效率高，其原因如下：
  **序列化速度快的原因：**
  ​	a. 编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）
  ​	b. 采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成

  **序列化后的数据量体积小（即数据压缩效果好）的原因：**
  ​	a. 采用了独特的编码方式，如Varint、Zigzag 编码方式等等
  ​	b. 采用T - L - V 的数据存储方式：减少了分隔符的使用 & 数据存储得紧凑

- **各个序列化技术的性能比较**
  这个地址有针对不同序列化技术进行性能比较：https://github.com/eishay/jvm-serializers/wiki

- **序列化技术的选型**

  - **技术层面**

    - 序列化空间开销，也就是序列化产生的结果大小，这个影响到传输的性能
    - 序列化过程中消耗的时长，序列化消耗时间过长影响到业务的响应时间
    - 序列化协议是否支持跨平台，跨语言。因为现在的架构更加灵活，如果存在异构系统通信需求，那么这个是必须要考虑的
    - 可扩展性/兼容性，在实际业务开发中，系统往往需要随着需求的快速迭代来实现快速更新，这就要求我们采用的序列化协议基于良好的可扩展性/兼容性，比如在现有的序列化数据结构中新增一个业务字段，不会影响到现有的服务
    - 技术的流行程度，越流行的技术意味着使用的公司多，那么很多坑都已经淌过并且得到了解决，技术解决方案也相对成熟
    - 学习难度和易用性

  - **选型建议**

    - 对性能要求不高的场景，可以采用基于XML 的SOAP 协议
    - 对性能和间接性有比较高要求的场景，那么Hessian、Protobuf、Thrift、Avro 都可以。
    - 基于前后端分离，或者独立的对外的api 服务，选用JSON 是比较好的，对于调试、可读性都很不错
    - Avro 设计理念偏于动态类型语言，那么这类的场景使用Avro 是可以的
























































