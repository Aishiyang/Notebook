## 分布式系统的基石-HTTP协议

- **Request请求**

  ![1556076867(1)](C:\Xingwei\Owner\Typora\Typora\Notebook\Distributed\images\1556076867(1).jpg)



- URI 是用一个字符串来表示互联网上的某一个资源。而URL表示资源的地点（互联网所在的位置）
- **HTTP 协议的缺陷**
  - 通信过程中是使用明文，内容可能会被窃听
  - 不验证通信双方的身份
  - 无法验证报文的完整性，报文可能被篡改
- **HTTPS 的原理**
  由于HTTP 协议通信的不安全性，所以人们为了防止信息在传输过程中遭到泄漏或者篡改，就想出来对传输通道进行加密的方式https。https 是一种加密的超文本传输协议，它与HTTP 在协议差异在于对数据传输的过程中，https 对数据做了完全加密。由于http 协议或者https协议都是处于TCP 传输层之上，同时网络协议又是一个分层的结构，所以在tcp 协议层之上增加了一层SSL（Secure Socket Layer，安全层）或者TLS（Transport Layer Security） 安全层传输协议组合使用用于构造加密通道；

​               ![1556077087(1)](C:\Xingwei\Owner\Typora\Typora\Notebook\Distributed\images\1556077087(1).jpg)

- **HTTPS 的实现原理**

  1. **客户端发起请求(Client Hello 包)**
     a) 三次握手，建立TCP 连接
     b) 支持的协议版本(TLS/SSL)
     c) 客户端生成的随机数client.random，后续用于生成“对话密钥”
     d) 客户端支持的加密算法
     e) sessionid，用于保持同一个会话（如果客户端与服务器费尽周折建立了一个HTTPS 链接，刚建完就断了，也太可惜）

  2. **服务端收到请求，然后响应（Server Hello）**

     a) 确认加密通道协议版本
     b) 服务端生成的随机数server.random，后续用于生成“对话密钥”

     c) 确认使用的加密算法（用于后续的握手消息进行签名防止篡改）

     d) 服务器证书（CA 机构颁发给服务端的证书）3. 客户端收到证书进行验证

  3. **客户端收到证书进行验证**	

     a) 验证证书是否是上级CA 签发的, 在验证证书的时候，浏览器会调用系统的证书管理器接口对证书路径中的所有证书一级一级的进行验证，只有路径中所有的证书都是受信的，整个验证的结果才是受信
     b) 服务端返回的证书中会包含证书的有效期，可以通过失效日期来验证 证书是否过期
     c) 验证证书是否被吊销了
     d) 前面我们知道CA 机构在签发证书的时候，都会使用自己的私钥对证书进行签名证书里的签名算法字段 sha256RSA 表示CA 机构使用sha256对证书进行摘要，然后使用RSA 算法对摘要进行私钥签名，而我们也知道RSA 算法中，使用私钥签名之后，只有公钥才能进行验签。
     e) 浏览器使用内置在操作系统上的CA机构的公钥对服务器的证书进行验签。确定这个证书是不是由正规的机构颁发。验签之后得知CA 机构使用sha256 进行证书摘要，然后客户端再使用sha256 对证书内容进行一次摘要，如果得到的值和服务端返回的证书验签之后的摘要相同，表示证书没有被修改过
     f) 验证通过后，就会显示绿色的安全字样
     g) 客户端生成随机数，验证通过之后，客户端会生成一个随机数pre-master secret ， 客户端根据之前的： Client.random +sever.random + pre-master 生成对称密钥然后使用证书中的公钥进行加密，同时利用前面协商好的加密算法，将握手消息取HASH 值，然后用“随机数加密“握手消息+握手消息HASH 值（签名）”然后传递给服务器端；(在这里之所以要取握手消息的HASH值，主要是把握手消息做一个签名，用于验证握手消息在传输过程中没有被篡改过。)

  4. **服务端接收随机数**

     a) 服务端收到客户端的加密数据以后，用自己的私钥对密文进行解密。然后得到client.random/server.random/pre-master secret. ,再用随机数密码 解密 握手消息与HASH 值，并与传过来的HASH 值做对比确认是否一致。
     b) 然后用随机密码加密一段握手消息(握手消息+握手消息的HASH 值 )给客户端

  5. **客户端接收消息**

     a) 客户端用随机数解密并计算握手消息的HASH，如果与服务端发来的HASH 一致，此时握手过程结束，
     b) 之后所有的通信数据将由之前交互过程中生成的pre mastersecret / client.random/server.random 通过算法得出sessionKey，作为后续交互过程中的对称密钥

​             ![1556077341(1)](C:\Xingwei\Owner\Typora\Typora\Notebook\Distributed\images\1556077341(1).jpg)





## 分布式系统的基石-TCP/IP协议

- **TCP/IP**

  TCP 协议能够检测和恢复IP 层提供的主机到主机的通信中可能发生的报文丢失、重复及其他错误。TCP 协议是一种面向连接的协议，在使用TCP进行通信之前，两个应用程序之间需要建立一个TCP 连接，而这个连接又涉及到两台电脑需要完成握手消息的交换。

  - **三次握手**

    ![1556076136756](C:\Users\xingwei.zhang\AppData\Roaming\Typora\typora-user-images\1556076136756.png)

  - **四次挥手**

  ![1556076184(1)](C:\Xingwei\Owner\Typora\Typora\Notebook\Distributed\images\1556076184(1).jpg)

- **UDP/IP**
  UDP 协议不会对IP 层产生的错误进行修复，而是简单的扩展了IP 协议“尽力而为”的数据报文服务，使他能够在应用程序之间工作，而不是在主机之间工作，因此使用UDP协议必须要考虑到报文丢失，顺序混乱的问题

- **为什么连接的时候是三次握手，关闭的时候却是四次握手？**
  三次握手是因为因为当Server 端收到Client 端的SYN 连接请求报文后，可以直接发送SYN+ACK 报文。其中ACK报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当Server 端收到FIN 报文时，很可能并不会立即关闭SOCKET（因为可能还有消息没处理完），所以只能先回复一个ACK 报文，告诉Client 端，"你发的FIN 报文我收到了"。只有等到我Server 端所有的报文都发送完了，我才能发送FIN 报文，因此不能一起发送。故需要四步握手。
- **数据传输过程的流量控制和确认机制**
  建立可靠连接以后，就开始进行数据传输了。在通信过程中，最重要的是数据包，也就是协议传输的数据。如果数据的传送与接收过程当中出现收方来不及接收的情况，这时就需要对发方进行控制以免数据丢失。利用滑动窗口机制可以很方便的在TCP 连接上实现对发送方的流量控制。TCP 的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。
  - **滑动窗口协议**
    滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题；发送和接受方都会维护一个数据帧的序列，这个序列被称作窗口。
  - 简单解释下，发送和接受方都会维护一个数据帧的序列，这个序列被称作窗口。发送方的窗口大小由接受方确定，目的在于控制发送速度，以免接受方的缓存不够大，而导致溢出，同时控制流量也可以避免网络拥塞。下面图中的4,5,6 号数据帧已经被发送出去，但是未收到关联的ACK，7,8,9 帧则是等待发送。可以看出发送端的窗口大小为6，这是由接受端告知的。此时如果发送端收到4 号ACK，则窗口的左边缘向右收缩，窗口的右边缘则向右扩展，此时窗口就向前“滑动了”，即数据帧10 也可以被发送。

​        ![1556076423(1)](C:\Xingwei\Owner\Typora\Typora\Notebook\Distributed\images\1556076423(1).jpg)



- **广播**
  广播是主机向子网内所有主机发送消息，子网内所有主机都能收到来自某台主机的广播信息，属于点对所有点的通信。广播意味着网络向子网每一个主机都投递一份数据包，不论这些主机是否乐意接收该数据包;
- **多播**
  多播是主机向一组主机发送信息，存在于某个组的所有主机都可以接收到消息，属于点对多点的通信。



## 分布式系统的基石-序列化

- **什么是序列化**

  Java 平台允许我们在内存中创建可复用的Java 对象，但一般情况下，只有当JVM 处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM 的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java 对象序列化就能够帮助我们实现该功能。

  简单来说，序列化是把对象的状态信息转化为可存储或传输的形式过程，也就是把对象转化为字节序列的过程称为对象的序列化反序列化是序列化的逆向过程，把字节数组反序列化为对象，把字节序
  列恢复为对象的过程成为对象的反序列化

- **SerialVersionUID 的作用**
  Java 的序列化机制是通过判断类的serialVersionUID 来验证版本一致性的。在进行反序列化时，JVM 会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即
  是InvalidCastException

  - 如果没有为指定的class 配置serialVersionUID，那么java 编译器会自动给这个class 进行一个摘要算法，类似于指纹算法，只要这个文件有任何改动，得到的UID 就会截然不同的，可以保证在这么多类中，这个编号是唯一的.。
  - **serialVersionUID 有两种显示的生成方式：**
    一是默认的1L，比如：private static final long serialVersionUID = 1L;
    二是根据类名、接口名、成员方法及属性等来生成一个64 位的哈希字段
  - 当实现java.io.Serializable 接口的类没有显式地定义一个serialVersionUID 变量时候，Java 序列化机制会根据编译的Class 自动生成一个serialVersionUID 作序列化版本比较用，这种情况下，如果
    Class 文件(类名，方法明等)没有发生变化(增加空格，换行，增加注释等等)，就算再编译多次，serialVersionUID 也不会变化的。

- **结论**

  - 当一个父类没有实现序列化时，子类继承该父类并且实现了序列化。在反序列化该子类后，是没办法获取到父类的属性值的
  - 当一个父类实现序列化，子类自动实现序列化，不需要再显示实现Serializable 接口
  - 当一个对象的实例变量引用了其他对象，序列化该对象时也会把引用对象进行序列化，但是前提是该引用对象必须实现序列化接口

- **Transient 关键字**

  - Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient变量的值被设为初始值，如 int 型的是 0，对象型的是 null。

- **常见的序列化技术**

  - **使用JAVA 进行序列化**
    优点：JAVA 语言本身提供，使用比较方便和简单
    缺点：不支持跨语言处理、 性能相对不是很好，序列化以后产生的数据相对较大

  - **XML 序列化框架**
    XML 序列化的好处在于可读性好，方便阅读和调试。但是序列化以后的字节码文件比较大，而且效率不高，适用于对性能不高，而且QPS 较低的企业级内部系统之间的数据交换的场景，同时XML 又具有语言无关性，所以还可以用于异构系统之间的数据交换和协议。比如我们熟知的Webservice，就是采用XML 格式对数据进行序列化的。

  - **JSON 序列化框架**
    JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，相对于XML 来说，JSON 的字节流更小，而且可读性也非常好。现在JSON数据格式在企业运用是最普遍的。

    - JSON 序列化常用的开源工具有很多
      - Jackson （https://github.com/FasterXML/jackson）
      - 阿里开源的FastJson （https://github.com/alibaba/fastjon）
      - Google 的GSON (https://github.com/google/gson)
    - 这几种json 序列化工具中，Jackson 与fastjson 要比GSON 的性能要好，但是Jackson、GSON 的稳定性要比Fastjson 好。而fastjson 的优势在于提供的api 非常容易使用。

  - **Hessian 序列化框架**
    Hessian 是一个支持跨语言传输的二进制序列化协议，相对于Java 默认的序列化机制来说，Hessian 具有更好的性能和易用性，而且支持多种不同的语言实际上Dubbo 采用的就是Hessian 序列化来实现，只不过Dubbo 对Hessian 进行了重构，性能更高。

  - **Protobuf 序列化框架**
    Protobuf 是Google 的一种数据交换格式，它独立于语言、独立于平台。Google 提供了多种语言来实现，比如Java、C、Go、Python，每一种实现都包含了相应语言的编译器和库文件Protobuf 使用比较广泛，主要是空间开销小和性能比较好，非常适合用于公司内部对性能要求高的RPC 调用。 另外由于解析性能比较高，序列化以后数据量相对较少，所以也可以应用在对象的持久化场景中
    但是但是要使用Protobuf 会相对来说麻烦些，因为他有自己的语法，有自己的编译器。

    - **Protobuf 原理分析**
      核心原理： protobuf 使用varint（zigzag）作为编码方式， 使用T-LV作为存储方式varint 编码方式varint 是一种数据压缩算法，其核心思想是利用bit 位来实现数据压缩。
      比如：对于 int32 类型的数字，一般需要 4 个字节 表示；若采用Varint 编码，对于很小的 int32 类型 数字，则可以用 1 个字节。
      假设我们定义了一个int32 字段值=296.
      **第一步，转化为2 进制编码**

      ![1556177730](C:\Xingwei\Owner\Typora\Typora\Notebook\Distributed\images\1556177730.jpg)

  ​              **第二步，提取字节**
  ​              规则： 按照从字节串末尾选取7 位，并在最高位补1，构成一个字节

  ![1556177774(1)](C:\Xingwei\Owner\Typora\Typora\Notebook\Distributed\images\1556177774(1).jpg)

  ​              **第三步，继续提取字节**
  ​	      整体右移7 位，继续截取7 个比特位，并且在最高位补0 。因为这个是最后一个有意义的字

  ​              节了。补0 不影响结果

  ![1556177843(1)](C:\Xingwei\Owner\Typora\Typora\Notebook\Distributed\images\1556177843(1).jpg)

​                     **第四步，拼接成一个新的字节串**
​                     将原来用4 个字节表示的整数，经过varint 编码以后只需要2 个字节了。

![1556177892(1)](C:\Xingwei\Owner\Typora\Typora\Notebook\Distributed\images\1556177892(1).jpg)



- **总结**
  Protocol Buffer 的性能好，主要体现在 序列化后的数据体积小 & 序列化速度快，最终使得传输效率高，其原因如下：
  **序列化速度快的原因：**
  ​	a. 编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）
  ​	b. 采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成

  **序列化后的数据量体积小（即数据压缩效果好）的原因：**
  ​	a. 采用了独特的编码方式，如Varint、Zigzag 编码方式等等
  ​	b. 采用T - L - V 的数据存储方式：减少了分隔符的使用 & 数据存储得紧凑

- **各个序列化技术的性能比较**
  这个地址有针对不同序列化技术进行性能比较：https://github.com/eishay/jvm-serializers/wiki

- **序列化技术的选型**

  - **技术层面**
    - 序列化空间开销，也就是序列化产生的结果大小，这个影响到传输的性能
    - 序列化过程中消耗的时长，序列化消耗时间过长影响到业务的响应时间
    - 序列化协议是否支持跨平台，跨语言。因为现在的架构更加灵活，如果存在异构系统通信需求，那么这个是必须要考虑的
    - 可扩展性/兼容性，在实际业务开发中，系统往往需要随着需求的快速迭代来实现快速更新，这就要求我们采用的序列化协议基于良好的可扩展性/兼容性，比如在现有的序列化数据结构中新增一个业务字段，不会影响到现有的服务
    - 技术的流行程度，越流行的技术意味着使用的公司多，那么很多坑都已经淌过并且得到了解决，技术解决方案也相对成熟
    - 学习难度和易用性
  - **选型建议**
    - 对性能要求不高的场景，可以采用基于XML 的SOAP 协议
    - 对性能和间接性有比较高要求的场景，那么Hessian、Protobuf、Thrift、Avro 都可以。
    - 基于前后端分离，或者独立的对外的api 服务，选用JSON 是比较好的，对于调试、可读性都很不错
    - Avro 设计理念偏于动态类型语言，那么这类的场景使用Avro 是可以的